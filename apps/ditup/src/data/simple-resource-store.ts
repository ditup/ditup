import type {
  ResourceStore,
  ResourceStoreCallback,
  ResourceStoreOptions,
  ResourceStoreResult,
  ResourceStoreUnsubscribe,
} from "./resource-store";

// generated by claude-opus-4-20250514-thinking-16k
// don't bother fixing manually...
export class SimpleResourceStore implements ResourceStore {
  private readonly fetch: typeof globalThis.fetch;
  private readonly cache = new Map<string, ResourceStoreResult<any>>();
  private readonly subscribers = new Map<
    string,
    Set<ResourceStoreCallback<any>>
  >();
  private readonly inflight = new Set<string>();
  private readonly redirectsTo = new Map<string, string>(); // original -> final
  private readonly redirectsFrom = new Map<string, Set<string>>(); // final -> originals

  constructor(fetch: typeof globalThis.fetch) {
    this.fetch = fetch;
  }

  private _key(uri: string, accept: string): string {
    return `${uri}|${accept}`;
  }

  subscribe<T = unknown>(
    uri: string,
    options: ResourceStoreOptions,
    callback: ResourceStoreCallback<T>
  ): ResourceStoreUnsubscribe {
    const key = this._key(uri, options.accept ?? "");

    // Add subscriber
    if (!this.subscribers.has(key)) {
      this.subscribers.set(key, new Set());
    }
    this.subscribers.get(key)!.add(callback as ResourceStoreCallback<any>);

    // Return cached if exists
    const cached = this.cache.get(key);
    if (cached) {
      callback(cached as ResourceStoreResult<T>);
    } else if (this.inflight.has(key)) {
      // Already fetching, send loading state
      callback({ loading: true });
    } else {
      // Start fetch
      this._fetch(uri, options.accept ?? "", key);
    }

    // Return unsubscribe
    return () => {
      this.subscribers.get(key)?.delete(callback as ResourceStoreCallback<any>);
    };
  }

  private async _fetch(
    uri: string,
    accept: string,
    key: string
  ): Promise<void> {
    this.inflight.add(key);

    // Notify loading
    const subscribers = this.subscribers.get(key) || new Set();
    for (const cb of subscribers) {
      cb({ loading: true });
    }

    try {
      const response = await this.fetch(uri, {
        headers: { Accept: accept },
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const contentType = response.headers.get("content-type") || "text/plain";
      let data: unknown;

      if (
        contentType.includes("application/json") ||
        contentType.includes("application/ld+json")
      ) {
        data = await response.json();
      } else if (contentType.includes("image/")) {
        data = await response.blob();
      } else {
        data = await response.text();
      }

      const finalUrl = response.url;

      // Track redirect if occurred
      if (finalUrl !== uri) {
        this.redirectsTo.set(uri, finalUrl);

        if (!this.redirectsFrom.has(finalUrl)) {
          this.redirectsFrom.set(finalUrl, new Set());
        }
        this.redirectsFrom.get(finalUrl)!.add(uri);
      }

      const result: ResourceStoreResult = {
        loading: false,
        finalUrl,
        headers: response.headers,
        contentType,
        data,
      };

      this.cache.set(key, result);
      this.inflight.delete(key);

      // Notify success
      for (const cb of subscribers) {
        cb(result);
      }
    } catch (error) {
      const result: ResourceStoreResult = {
        loading: false,
        error: error instanceof Error ? error : new Error(String(error)),
      };

      this.cache.set(key, result);
      this.inflight.delete(key);

      // Notify error
      for (const cb of subscribers) {
        cb(result);
      }
    }
  }

  private _findRelatedUrls(uri: string): Set<string> {
    const urls = new Set([uri]);

    // Add final URL if this is original
    const finalUrl = this.redirectsTo.get(uri);
    if (finalUrl) {
      urls.add(finalUrl);
    }

    // Add all original URLs if this is final
    const originals = this.redirectsFrom.get(uri);
    if (originals) {
      for (const original of originals) {
        urls.add(original);
      }
    }

    return urls;
  }

  invalidate(uri: string, options?: ResourceStoreOptions): void {
    const relatedUrls = this._findRelatedUrls(uri);

    for (const url of relatedUrls) {
      if (options) {
        // Invalidate specific content type
        const key = this._key(url, options.accept ?? "");
        this.cache.delete(key);
        if (this.subscribers.has(key) && !this.inflight.has(key)) {
          this._fetch(url, options.accept ?? "", key);
        }
      } else {
        // Invalidate all content types for this URL
        const keys = Array.from(this.cache.keys()).filter((k) =>
          k.startsWith(url + "|")
        );
        for (const key of keys) {
          this.cache.delete(key);
          const [, accept] = key.split("|");
          if (accept && this.subscribers.has(key) && !this.inflight.has(key)) {
            this._fetch(url, accept, key);
          }
        }
      }
    }
  }
}
